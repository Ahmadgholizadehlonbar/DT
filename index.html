<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Cloud Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }
        #fileInput {
            margin-bottom: 10px;
        }
        button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        button:hover {
            background: #106ebe;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
        }
        .label {
            font-weight: bold;
            margin-top: 10px;
            display: block;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3 style="margin-top: 0;">Point Cloud Viewer</h3>
        <input type="file" id="fileInput" accept=".ply,.xyz,.txt,.pcd" />
        <div>
            <span class="label">Point Size:</span>
            <input type="range" id="pointSize" min="0.5" max="5" step="0.5" value="2" />
            <span id="pointSizeValue">2</span>
        </div>
    </div>
    <div id="info">
        Click on a point to select it<br>
        Left mouse: Rotate | Right mouse: Pan | Scroll: Zoom
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls, pointCloud;
        let selectedPoint = null;
        let selectionMarker = null;
        let raycaster, mouse;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20);
            scene.add(gridHelper);

            // Raycaster for point selection
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.1;
            mouse = new THREE.Vector2();

            // Basic orbit controls (simplified)
            setupControls();

            // Event listeners
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('pointSize').addEventListener('input', (e) => {
                document.getElementById('pointSizeValue').textContent = e.target.value;
                if (pointCloud) {
                    pointCloud.material.size = parseFloat(e.target.value);
                }
            });
            renderer.domElement.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let isRightButton = false;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                isRightButton = e.button === 2;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                if (isRightButton) {
                    // Pan
                    const panSpeed = 0.01;
                    camera.position.x -= deltaX * panSpeed;
                    camera.position.y += deltaY * panSpeed;
                } else {
                    // Rotate
                    const rotateSpeed = 0.005;
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(camera.position);
                    spherical.theta -= deltaX * rotateSpeed;
                    spherical.phi -= deltaY * rotateSpeed;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    camera.position.setFromSpherical(spherical);
                    camera.lookAt(0, 0, 0);
                }

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + delta * zoomSpeed);
            });

            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const extension = file.name.split('.').pop().toLowerCase();

                if (extension === 'ply') {
                    parsePLY(content);
                } else if (extension === 'xyz' || extension === 'txt') {
                    parseXYZ(content);
                }
            };

            if (file.name.endsWith('.ply')) {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }

        function parsePLY(buffer) {
            const data = new Uint8Array(buffer);
            const text = new TextDecoder().decode(data.slice(0, 5000));
            
            const headerEnd = text.indexOf('end_header') + 'end_header\n'.length;
            const header = text.substring(0, headerEnd);
            
            const vertexMatch = header.match(/element vertex (\d+)/);
            if (!vertexMatch) return;
            
            const vertexCount = parseInt(vertexMatch[1]);
            const isBinary = header.includes('format binary');
            const isAscii = header.includes('format ascii');
            
            // Parse property order
            const properties = [];
            const propLines = header.split('\n').filter(l => l.startsWith('property'));
            propLines.forEach(line => {
                const parts = line.split(/\s+/);
                const type = parts[1];
                const name = parts[2];
                properties.push({ name, type });
            });
            
            console.log('Properties:', properties);
            console.log('Vertex count:', vertexCount);
            
            if (isAscii) {
                // ASCII format
                const bodyText = new TextDecoder().decode(data.slice(headerEnd));
                const lines = bodyText.split('\n').filter(l => l.trim());
                const positions = [];
                const colors = [];
                
                for (let i = 0; i < Math.min(lines.length, vertexCount); i++) {
                    const parts = lines[i].trim().split(/\s+/).map(parseFloat);
                    if (parts.length >= 3 && !isNaN(parts[0])) {
                        positions.push(parts[0], parts[1], parts[2]);
                        if (parts.length >= 6) {
                            colors.push(parts[3] / 255, parts[4] / 255, parts[5] / 255);
                        }
                    }
                }
                
                const posArray = new Float32Array(positions);
                const colArray = colors.length > 0 ? new Float32Array(colors) : null;
                createPointCloud(posArray, colArray, positions.length / 3);
            } else if (isBinary) {
                // Find binary start
                let binaryStart = 0;
                for (let i = 0; i < data.length - 11; i++) {
                    if (data[i] === 101 && data[i+1] === 110 && data[i+2] === 100) { // "end"
                        const chunk = new TextDecoder().decode(data.slice(i, i + 11));
                        if (chunk === 'end_header\n') {
                            binaryStart = i + 11;
                            break;
                        }
                    }
                }
                
                console.log('Binary start:', binaryStart);
                
                const dataView = new DataView(buffer, binaryStart);
                const positions = new Float32Array(vertexCount * 3);
                const colors = header.includes('red') ? new Float32Array(vertexCount * 3) : null;
                
                // Calculate stride
                let stride = 0;
                properties.forEach(p => {
                    if (p.type === 'float') stride += 4;
                    else if (p.type === 'uchar') stride += 1;
                    else if (p.type === 'double') stride += 8;
                });
                
                console.log('Stride:', stride);
                
                for (let i = 0; i < vertexCount; i++) {
                    const offset = i * stride;
                    positions[i * 3] = dataView.getFloat32(offset, true);
                    positions[i * 3 + 1] = dataView.getFloat32(offset + 4, true);
                    positions[i * 3 + 2] = dataView.getFloat32(offset + 8, true);
                    
                    if (colors && stride >= 15) {
                        colors[i * 3] = dataView.getUint8(offset + 12) / 255;
                        colors[i * 3 + 1] = dataView.getUint8(offset + 13) / 255;
                        colors[i * 3 + 2] = dataView.getUint8(offset + 14) / 255;
                    }
                }
                
                createPointCloud(positions, colors, vertexCount);
            }
        }

        function parseXYZ(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const positions = [];
            const colors = [];
            
            for (const line of lines) {
                const parts = line.trim().split(/\s+/).map(parseFloat);
                if (parts.length >= 3) {
                    positions.push(parts[0], parts[1], parts[2]);
                    if (parts.length >= 6) {
                        colors.push(parts[3] / 255, parts[4] / 255, parts[5] / 255);
                    }
                }
            }
            
            const posArray = new Float32Array(positions);
            const colArray = colors.length > 0 ? new Float32Array(colors) : null;
            createPointCloud(posArray, colArray, positions.length / 3);
        }

        function createPointCloud(positions, colors, count) {
            if (pointCloud) {
                scene.remove(pointCloud);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            if (colors) {
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            }

            const material = new THREE.PointsMaterial({
                size: parseFloat(document.getElementById('pointSize').value),
                vertexColors: colors ? true : false,
                color: colors ? 0xffffff : 0x00aaff
            });

            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);

            // Center camera on point cloud
            geometry.computeBoundingSphere();
            const center = geometry.boundingSphere.center.clone();
            const radius = geometry.boundingSphere.radius;
            
            // Move point cloud to origin
            pointCloud.position.set(-center.x, -center.y, -center.z);
            
            // Position camera
            const distance = radius * 2.5;
            camera.position.set(distance, distance, distance);
            camera.lookAt(0, 0, 0);
            
            // Update grid size based on point cloud
            scene.children.forEach(child => {
                if (child instanceof THREE.GridHelper) {
                    scene.remove(child);
                }
            });
            const gridSize = Math.max(20, radius * 3);
            const gridHelper = new THREE.GridHelper(gridSize, 20);
            scene.add(gridHelper);

            console.log(`Loaded ${count} points, center: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}), radius: ${radius.toFixed(2)}`);
        }

        function onMouseClick(event) {
            if (!pointCloud) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(pointCloud);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                selectPoint(point);
                console.log('Selected point:', point);
            }
        }

        function selectPoint(point) {
            selectedPoint = point;

            // Remove old marker
            if (selectionMarker) {
                scene.remove(selectionMarker);
            }

            // Create marker
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            selectionMarker = new THREE.Mesh(geometry, material);
            selectionMarker.position.copy(point);
            scene.add(selectionMarker);

            // Update info
            document.getElementById('info').innerHTML = `
                Selected Point: (${point.x.toFixed(2)}, ${point.y.toFixed(2)}, ${point.z.toFixed(2)})<br>
                Left mouse: Rotate | Right mouse: Pan | Scroll: Zoom
            `;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
